<div id="linkingContainer">
  <div class="card card-body">
    <h2 style="font-size: 0.9rem; font-weight: 300;">Device Linking</h2>
    <button class="btn btn-primary" id="generateQR"
      style="font-weight: 400; padding: .375rem .75rem; font-size: 1rem; line-height: 1.5; border-radius: .25rem; text-transform: uppercase;">Connect to PalGate</button>
    <!-- Added style to center the QR code -->
    <div id="qrCodeArea" class="mt-3" style="text-align: center;"></div>
    <div id="linkStatus" class="mt-2"></div>
    <br>
    <h2 style="font-size: 0.9rem; font-weight: 300;">Customise Gates</h2>
    <button class="btn btn-primary" id="discoverGates"
      style="font-weight: 400; padding: .375rem .75rem; font-size: 01rem; line-height: 1.5; border-radius: .25rem; text-transform: uppercase;">
      Customise Gates
    </button>
    <div id="gateList" class="mt-3"></div>
  </div>
</div>
<br>
<div >
  <button class="btn btn-outline-secondary btn-sm" id="toggleManualConfig"
    style="font-weight: 400; padding: .375rem .75rem; font-size: 0.8rem; line-height: 1.2; border-radius: .25rem; text-transform: uppercase;">
    Show Manual Config
  </button>
</div>

<!-- Removed "display:none;" to always show the form -->

<style>
  .customize-toggle {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    margin-top: 4px;
  }
  .customize-toggle-label {
    color: rgb(255, 255, 255);
    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', 'Noto Sans', 'Liberation Sans', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
    font-size: 14.4px;
    font-weight: 300;
    line-height: 24px;
    display: flex;
    align-items: center;
    flex: 1;
    margin-right: 0;
  }
  .customize-toggle .hb-uix-switch {
    margin-left: 0;
  }
</style>

<script>
  (async () => {

    // Retrieve current plugin configuration.
    let pluginConfig = await homebridge.getPluginConfig();
    // Look for an existing configuration for PalGatePlatform.
    let config = pluginConfig.find(item => item.platform === "PalGatePlatform");
    if (!config) {
      // If not found, create one.
      config = {
        platform: "PalGatePlatform",
        name: "PalGate Platform",
        accessoryType: "garageDoor"
      };
      pluginConfig.push(config);
      await homebridge.updatePluginConfig(pluginConfig);
    }
    config.customGates = Array.isArray(config.customGates) ? config.customGates : [];

    // Linking flow variables.
    let uniqueId = null;
    let pollInterval = null;
    let linkingComplete = false; // Guard flag to prevent multiple success events

    const linkStatusEl = document.getElementById('linkStatus');
    const gateListEl = document.getElementById('gateList');
    const discoverBtn = document.getElementById('discoverGates');
    const manualConfigToggleBtn = document.getElementById('toggleManualConfig');
    const manualConfigStorageKey = 'palgateManualConfigVisible';
    let manualConfigVisible = false;

    try {
      const storedPreference = localStorage.getItem(manualConfigStorageKey);
      if (storedPreference !== null) {
        manualConfigVisible = storedPreference === 'true';
      }
    } catch (err) {
      manualConfigVisible = false;
    }

    if (manualConfigToggleBtn) {
      manualConfigToggleBtn.addEventListener('click', () => {
        manualConfigVisible = !manualConfigVisible;
        try {
          localStorage.setItem(manualConfigStorageKey, manualConfigVisible);
        } catch (err) {
          // ignore storage write errors
        }
        updateManualConfigVisibility();
      });
    }

    updateManualConfigVisibility();
    updateDiscoverButtonState();
    homebridge.hideSpinner();

    let discoveredGates = [];

    document.getElementById('generateQR').addEventListener('click', async () => {
      // Clear any existing polling interval and reset linking flag.
      if (pollInterval) {
        clearInterval(pollInterval);
      }
      linkingComplete = false;
      homebridge.showSpinner();
      setStatus(linkStatusEl, 'info', 'Preparing linking session...');


      try {
        // Call /link/init to get a new uniqueId and QR code.
        const initData = await homebridge.request('/link/init');
        if (!initData.success) {
          throw new Error(initData.error || 'Failed to initiate linking.');
        }
        uniqueId = initData.uniqueId;
        document.getElementById('qrCodeArea').innerHTML = `
          <div style="display: flex; align-items: center; justify-content: center; gap: 1rem;">
            <img src="${initData.qrCode}" alt="QR Code" style="max-width:100%;">
            <div style="font-size: 0.9rem; font-weight: 300;">
              Open the PalGate App and go to Device Linking > Link a Device to scan the QR code and complete the setup.
            </div>
          </div>
        `;
        homebridge.hideSpinner();
        setStatus(linkStatusEl);
        
        
        // Start polling /link/confirm.
        startConfirmationPolling(uniqueId);
       
      } catch (err) {
        const friendly = formatError(err);
        setStatus(linkStatusEl, 'error', friendly);
        homebridge.toast.error(friendly, 'Error');
      } finally {
        homebridge.hideSpinner();
      }
    });

    if (discoverBtn) {
      discoverBtn.addEventListener('click', async () => {
        if (!hasLinkingCredentials()) {
          homebridge.toast.error('Please link your device before discovering gates.', 'Missing Credentials');
          return;
        }

        setStatus(gateListEl, 'info', 'Discovering devices...');
        homebridge.showSpinner();

        try {
          const discoveryData = await homebridge.request('/devices/discover', {
            token: config.token,
            phoneNumber: config.phoneNumber,
            tokenType: config.tokenType
          });
          if (!discoveryData.success) {
            throw new Error(discoveryData.error || 'Failed to discover devices.');
          }
          discoveredGates = discoveryData.gates || [];
          renderGateList(discoveredGates);
        } catch (err) {
          const friendly = formatError(err);
          setStatus(gateListEl, 'error', friendly);
          homebridge.toast.error(friendly, 'Discovery Error');
        } finally {
          homebridge.hideSpinner();
        }
      });
    }

    function renderGateList(gates) {
      discoveredGates = gates || [];
      if (!gates || gates.length === 0) {
        setStatus(gateListEl, 'info', 'No gates discovered.');
        return;
      }

      gateListEl.innerHTML = '';
      gates.forEach((gate) => {
        gateListEl.appendChild(createGateCard(gate));
      });
    }

    function createGateCard(gate) {
      const card = document.createElement('div');
      card.className = 'card card-body mb-2';
      const displayName = gate.defaultName || gate.deviceId;
      card.innerHTML = `
        <div class="d-flex justify-content-between align-items-center flex-wrap">
          <div>
            <div style="font-weight: 600;">${escapeHtml(displayName)}</div>
            <div style="font-size: 0.8rem; color: #6c757d;">${escapeHtml(gate.deviceId)}</div>
          </div>
          <button class="btn btn-secondary btn-sm customize-btn">Customise</button>
        </div>
        <div class="customize-form mt-3" style="display: none;"></div>
      `;

      const customizeBtn = card.querySelector('.customize-btn');
      const formContainer = card.querySelector('.customize-form');

      customizeBtn.addEventListener('click', () => {
        if (formContainer.style.display === 'none' || formContainer.style.display === '') {
          renderCustomizationForm(formContainer, gate);
        } else {
          formContainer.style.display = 'none';
        }
      });

      return card;
    }

    function renderCustomizationForm(container, gate) {
      const customEntry = (config.customGates || []).find(item => item.deviceId === gate.deviceId);
      const sanitizedId = gate.deviceId.replace(/[^a-zA-Z0-9_-]/g, '_');
      const customName = customEntry && customEntry.name ? customEntry.name : '';
      const defaultGarageDoor = customEntry ? customEntry.garageDoor === true : config.accessoryType !== 'switch';
      const defaultSwitch = customEntry ? customEntry.switch === true : config.accessoryType === 'switch';
      const hideGate = customEntry ? customEntry.hide === true : false;

      container.innerHTML = `
        <div class="form-group">
          <label for="customName-${sanitizedId}" style="display: block; height: 24px; line-height: 24px; margin-bottom: 4px; font-size: 14.4px;">
            Custom Gate Name
          </label>
          <input
            type="text"
            class="form-control"
            id="customName-${sanitizedId}"
            value="${escapeHtml(customName)}"
            placeholder="${escapeHtml(gate.defaultName || gate.deviceId)}"
            style="
              appearance: none;
              background-color: rgb(36, 36, 36);
              border: 1px solid rgb(36, 36, 36);
              border-radius: 6px;
              box-sizing: border-box;
              color: rgb(255, 255, 255);
              font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', 'Noto Sans', 'Liberation Sans', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
              font-size: 16px;
              font-weight: 400;
              height: 38px;
              line-height: 24px;
              padding: 6px 12px;
              transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
              width: 100%;
              margin-bottom: 16px;
              margin-top: 4px;
            "
          />
        </div>
        <div class="form-group schema-form-checkbox">
          <label class="hb-uix-switch">
            <input type="checkbox" id="garage-${sanitizedId}" ${defaultGarageDoor ? 'checked' : ''}>
            <span class="hb-uix-slider hb-uix-round"></span>
            <span class="customize-toggle-label">Expose as Garage Door</span>
          </label>

        </div>
        <div class="form-group schema-form-checkbox">
          <label class="hb-uix-switch">
            <input type="checkbox" id="switch-${sanitizedId}" ${defaultSwitch ? 'checked' : ''}>
            <span class="hb-uix-slider hb-uix-round"></span>         
            <span class="customize-toggle-label">Expose as Switch</span>
          </label>

        </div>
        <div class="form-group schema-form-checkbox">
          <label class="hb-uix-switch">
            <input type="checkbox" id="hide-${sanitizedId}" ${hideGate ? 'checked' : ''}>
            <span class="hb-uix-slider hb-uix-round"></span>
            <span class="customize-toggle-label">Hide Gate</span>
          </label>
        </div>
        <div class="mt-3">
          <button class="btn btn-primary btn-sm save-custom" style="margin-right: 0.5rem;">Save</button>
          <button class="btn btn-outline-secondary btn-sm cancel-custom">Cancel</button>
        </div>
      `;
      container.style.display = 'block';

      const nameInput = container.querySelector(`#customName-${sanitizedId}`);
      const garageInput = container.querySelector(`#garage-${sanitizedId}`);
      const switchInput = container.querySelector(`#switch-${sanitizedId}`);
      const hideInput = container.querySelector(`#hide-${sanitizedId}`);

      container.querySelector('.cancel-custom').addEventListener('click', (event) => {
        event.preventDefault();
        container.style.display = 'none';
      });

      container.querySelector('.save-custom').addEventListener('click', async (event) => {
        event.preventDefault();
        await saveCustomGate(gate, {
          name: nameInput.value.trim(),
          garageDoor: garageInput.checked,
          switchDevice: switchInput.checked,
          hide: hideInput.checked
        }, container);
      });
    }

    async function saveCustomGate(gate, values, container) {
      const entry = {
        deviceId: gate.deviceId,
        hide: values.hide,
        garageDoor: values.garageDoor,
        switch: values.switchDevice
      };
      if (values.name && values.name.length > 0) {
        entry.name = values.name;
      } else {
        delete entry.name;
      }

      config.customGates = Array.isArray(config.customGates) ? config.customGates : [];
      const existingIndex = config.customGates.findIndex(item => item.deviceId === gate.deviceId);
      if (existingIndex > -1) {
        config.customGates[existingIndex] = entry;
      } else {
        config.customGates.push(entry);
      }

      try {
        homebridge.showSpinner();
        await persistPluginConfig({ refreshSchema: true });
        homebridge.toast.success('Custom gate settings saved.', gate.defaultName || gate.deviceId);
        container.style.display = 'none';
        renderGateList(discoveredGates);
      } catch (err) {
        const friendly = formatError(err);
        homebridge.toast.error(friendly, 'Save Failed');
      } finally {
        homebridge.hideSpinner();
      }
    }

    async function reloadPluginConfigState() {
      pluginConfig = await homebridge.getPluginConfig();
      config = pluginConfig.find(item => item.platform === "PalGatePlatform");
      if (!config) {
        config = {
          platform: "PalGatePlatform",
          name: "PalGate Platform",
          accessoryType: "garageDoor"
        };
        pluginConfig.push(config);
      }
      config.customGates = Array.isArray(config.customGates) ? config.customGates : [];
    }

    async function persistPluginConfig(options = {}) {
      await homebridge.updatePluginConfig(pluginConfig);
      await homebridge.savePluginConfig();
      if (options.refreshSchema) {
        if (manualConfigVisible) {
          await homebridge.showSchemaForm();
        } else {
          hideSchemaFormIfSupported();
        }
      }
      await reloadPluginConfigState();
      updateDiscoverButtonState();
    }

    function updateManualConfigVisibility() {
      if (manualConfigToggleBtn) {
        manualConfigToggleBtn.textContent = manualConfigVisible ? 'Hide Manual Config' : 'Show Manual Config';
      }
      if (manualConfigVisible) {
        homebridge.showSchemaForm();
      } else {
        hideSchemaFormIfSupported();
      }
    }

    function hideSchemaFormIfSupported() {
      if (typeof homebridge.hideSchemaForm === 'function') {
        homebridge.hideSchemaForm();
      }
    }

    function hasLinkingCredentials() {
      return Boolean(config.token && config.phoneNumber && (config.tokenType !== undefined && config.tokenType !== null));
    }

    function updateDiscoverButtonState() {
      if (!discoverBtn) {
        return;
      }
      const enabled = hasLinkingCredentials();
      discoverBtn.disabled = !enabled;
      discoverBtn.title = enabled ? '' : 'Link your device to discover gates';
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function startConfirmationPolling(uniqueId) {
      const poll = async () => {
        if (linkingComplete) {
          return;
        }
        try {
          const confirmData = await homebridge.request('/link/confirm', { uniqueId });
          if (confirmData.success) {
            if (linkingComplete) {
              return;
            }
            linkingComplete = true;
            if (pollInterval) {
              clearInterval(pollInterval);
              pollInterval = null;
            }
            document.getElementById('qrCodeArea').innerHTML = '';
            setStatus(linkStatusEl, 'success', 'Linking complete, plugin configuration updated.');
            homebridge.toast.success(
              `Successfully linked. Session token: ${confirmData.sessionToken}`,
              'Linking Complete'
            );
            config.token = confirmData.sessionToken;
            config.phoneNumber = confirmData.phoneNumber;
            config.tokenType = parseInt(confirmData.tokenType, 10);
            await persistPluginConfig({ refreshSchema: true });
          } else if (confirmData.waiting) {
            setStatus(linkStatusEl, 'info', 'Waiting for scan confirmation...');
          } else {
            if (pollInterval) {
              clearInterval(pollInterval);
              pollInterval = null;
            }
            const errMsg = confirmData.error || 'Unknown error';
            setStatus(linkStatusEl, 'error', errMsg);
            homebridge.toast.error(errMsg, 'Error');
          }
        } catch (err) {
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
          const friendly = formatError(err);
          setStatus(linkStatusEl, 'error', friendly);
          homebridge.toast.error(friendly, 'Error');
        }
      };

      poll();
      pollInterval = setInterval(poll, 3000);
    }

    function setStatus(element, type, message) {
      if (!element) {
        return;
      }
      if (!message) {
        element.innerHTML = '';
        return;
      }
      const variantMap = {
        info: 'alert-info',
        success: 'alert-success',
        error: 'alert-danger'
      };
      const alertClass = variantMap[type] || 'alert-secondary';
      element.innerHTML = `<div class="alert ${alertClass} mb-0">${escapeHtml(message)}</div>`;
    }

    function formatError(err) {
      if (!err) {
        return 'Unknown error occurred.';
      }
      const message =
        (typeof err === 'string' && err) ||
        err.message ||
        (typeof err.toString === 'function' ? err.toString() : '') ||
        '';
      if (/504/.test(message)) {
        return 'The PalGate server timed out. Please try again in a moment.';
      }
      return message || 'Unknown error occurred.';
    }
  })();
</script>
